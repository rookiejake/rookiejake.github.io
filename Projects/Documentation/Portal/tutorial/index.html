<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
        <meta name="description" />
        <meta name="keywords"
            content="static content generator,static site generator,static site,HTML,web development,.NET,C#,Razor,Markdown,YAML" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="shortcut icon" href="/2019.CRCS-WebSite/Documentation/assets/img/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/2019.CRCS-WebSite/Documentation/assets/img/favicon.ico" type="image/x-icon">
        <title>Summer 2018 ASL Documentation - Portal Tutorial</title>
        <link href="/2019.CRCS-WebSite/Documentation/assets/css/mermaid.css" rel="stylesheet">
        <link href="/2019.CRCS-WebSite/Documentation/assets/css/highlight.css" rel="stylesheet">
        <link href="/2019.CRCS-WebSite/Documentation/assets/css/bootstrap/bootstrap.css" rel="stylesheet" />
        <link href="/2019.CRCS-WebSite/Documentation/assets/css/adminlte/AdminLTE.css" rel="stylesheet" />
        <link href="/2019.CRCS-WebSite/Documentation/assets/css/theme/theme.css" rel="stylesheet" />
        <link href="//fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,400i,700,700i" rel="stylesheet">
        <link href="/2019.CRCS-WebSite/Documentation/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href="/2019.CRCS-WebSite/Documentation/assets/css/override.css" rel="stylesheet" />
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/jquery-2.2.3.min.js"></script>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/bootstrap.min.js"></script>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/app.min.js"></script>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/highlight.pack.js"></script>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/jquery.slimscroll.min.js"></script>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/jquery.sticky-kit.min.js"></script>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/mermaid.min.js"></script>
        <!--[if lt IE 9]>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/html5shiv.min.js"></script>
        <script src="/2019.CRCS-WebSite/Documentation/assets/js/respond.min.js"></script>
        <![endif]-->


    </head>

    <body class="hold-transition wyam layout-boxed layout-top-nav ">
        <div class="top-banner"></div>
        <div class="wrapper with-container">
            <!-- Header -->
            <header class="main-header">

                <a href="/2019.CRCS-WebSite/Documentation/" class="logo">

                    <!-- mini logo for sidebar mini 50x50 pixels -->
                    <span class="logo-mini"><img src="/2019.CRCS-WebSite/Documentation/assets/img/favicon.png"></span>
                    <!-- logo for regular state and mobile devices -->
                    <span class="logo-lg"><img src="/2019.CRCS-WebSite/Documentation/assets/img/favicon.png"></span>
                </a>

                <nav class="navbar navbar-static-top" role="navigation">
                    <!-- Sidebar toggle button-->

                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                            data-target="#navbar-collapse">
                            <span class="sr-only">Toggle side menu</span>
                            <i class="fa fa-chevron-circle-down"></i>
                        </button>
                    </div>

                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse pull-left" id="navbar-collapse">
                        <ul class="nav navbar-nav">
                            <li><a href="/2019.CRCS-WebSite/Documentation/api">API</a></li>
                            <li><a href="/2019.CRCS-WebSite/Documentation/demos">Demos</a></li>
                            <li><a href="/2019.CRCS-WebSite/Documentation/Portal/tutorial">Portal Tutorial</a></li>
                            <li><a href="/2019.CRCS-WebSite/Documentation/VR/tutorial">Virtual Reality Tutorial</a></li>
                            <li><a href="/2019.CRCS-WebSite/Documentation/localEvents">Local Event System</a></li>
                        </ul>
                    </div>
                    <!-- /.navbar-collapse -->

                    <!-- Navbar Right Menu -->
                </nav>
            </header>

            <!-- Left side column. contains the logo and sidebar -->
            <aside class="main-sidebar hidden">
                <section class="infobar" data-spy="affix" data-offset-top="60" data-offset-bottom="200">

                    <div id="infobar-headings"></div>

                </section>
                <section class="sidebar">



                    <ul class="sidebar-menu">


                    </ul>

                </section>
            </aside>

            <!-- Content Wrapper. Contains page content -->
            <div class="content-wrapper">




                <section class="content-header">
                    <h1>Portal System Tutorial</h1>
                </section>
                <section class="content">
                    <h1>Starting With ASL</h1>
                    <h2>Setting Up the Project</h2>
                    <p>To use ASL in a Unity project, start by importing ASL into the Assets folder. The repository can
                        be cloned using the following address: https://github.com/UWB-ARSandbox/ASL.git. You will also
                        want to create two different scenes, one for the Master Client and one for other Clients. If you
                        already have a scene, duplicate it and name them accordingly. Then you want to add two prefabs
                        to your scenes, both found in ASL/Resources/Prefabs. First is the NetworkManager, which contains
                        scripts that make collaboration over the network possible. Click on the NetworkManager
                        GameObject and look at the NetworkManager script in Unity's Inspector.</p>
                    <p><b>Note:</b> You will also have to clone the Room_Texture module into the Room_texture folder.
                    </p>
                    <img width=433 height=507 src="/2019.CRCS-WebSite/Documentation/assets/img/image002.png">
                    <p>Notice the Master Client checkbox. This must be checked in your Master scene and unchecked in the
                        Client scene. Also make sure to use the same Port number and Room Name in both scenes (can be
                        whatever you like, but should be something unique). The second prefab you want to add to both
                        scenes is the ObjectInteractionManager, which initializes controllers for the device your
                        project uses. No further configuration is required for this one. </p>
                    <h2>Using ASL</h2>
                    <p>Test your project is setup correctly by playing the Master scene, which should always be played
                        first. It should show that it is connecting, and then connected to the given Room Name. </p>
                    <img width=267 height=114 src="/2019.CRCS-WebSite/Documentation/assets/img/image003.png">
                    <p>Then, in another instance of Unity, open your Client scene and play it alongside your Master
                        scene (while it is still running and connected). You should see that it connects to the same
                        room. Now that you have multiple Clients in the same room, let's try instantiating objects that
                        all Clients can see. All you have to do is write a simple script that contains a reference to
                        the NetworkManager, and call the InstantiateOwnedObject method. For this to work correctly, you
                        always have to instantiate prefabs that exist within ASL/Resources using the name of your chosen
                        prefab (that means you MUST add your own prefabs to that folder, or subfolder, for them to be
                        instantiated this way). For example, your script can respond to a right click by calling
                        InstantiateOwnedObject("Sphere"). This will instantiate the Sphere prefab in ASL/Resources for
                        all Clients. It will also ensure that the sphere is synchronized between all Clients, so that if
                        it moves, scales, or rotates in one scene, it will do the same in every other Clients' scene.
                    </p>

                    <h3>Prefab Instantiation</h3>
                    <p>Objects can be created using the PrefabInstantiator, removing the need to write a script for
                        static objects. To use the prefab instantiator simply drag it from 'ASL/Utility' into the scene.
                    </p>
                    <img width=800 src="/2019.CRCS-WebSite/Documentation/assets/img/PrefabInstantiator.PNG">
                    <p>Then simply drag a prefab located in a resources folder into the prefab reference field.
                        You can then use the transform to set the scale and location for the prefab. The purple cube
                        will act as a visual representation
                        for the relative scale and location of the prefab upon instantiation.</p>
                    <p><b>Note:</b> See <a
                            href="/2019.CRCS-WebSite/Documentation/api/ASL.PlayerSystem/ControllerInstantiation/">
                            ControllerInstantiation </a> for an example
                        of more sophisticated instantiation.</p>

                    <h1>How to Use the WorldSystem</h1>
                    <h2>The WorldManager Object</h2>
                    <p>Any Scene that needs to use ASL's World System MUST include one WorldManager Object. This object
                        can be found in ASL/WorldSystem. The only property you need to modify in the WorldManager is a
                        Boolean telling if your application is the master client. This ensures that only the master
                        client has control over the Worlds that are present.</p>
                    <img width=510 height=63 src="/2019.CRCS-WebSite/Documentation/assets/img/image004.png">
                    <h2>Making New Worlds</h2>
                    <p>To make a new world, simply place all the GameObjects you wish to be in the world underneath a
                        root GameObject that has a World script, or a script derived from the World script. Save all
                        your objects including the root object in the world as a prefab under the ASL/Resources/Worlds
                        directory.</p>
                    <img width=623 height=293 src="/2019.CRCS-WebSite/Documentation/assets/img/image006.jpg">
                    <h2>The World Class</h2>
                    <p>Basic World class doesn't really do anything, but it does contain references to the WorldManager
                        and NetworkManager.
                        If you have initialization logic, etc. for your worlds, make a new World-type class that
                        inherits from this one, and give it the extra functionality it needs.</p>
                    <h2>Loading Worlds at Runtime</h2>
                    <p>To load a world at runtime, call the CreateWorld() method in the WorldManager, and pass in the
                        name of the prefab you saved earlier. The WorldManager Will attempt to instantiate the prefab,
                        and register it with the system, triggering all of the other clients with WorldManagers to do
                        the same.</p>
                    <h2>World-type Class Examples</h2>
                    <p>The following are some examples of how the WorldSystem has been used before:</p>
                    <h3>PortalWorld</h3>
                    <p>PortalWorlds use the PortalSystem (more on this below), as the name implies. Each comes with a
                        default portal, and a portal selector which allows you to cycle destinations. You can choose
                        what type of portal you want to use with the "Default Portal View Type" Drop-down (VIRTUAL,
                        PHYSICAL, or HYBRID). To have a spawn location for the default portal, give the PortalWorld a
                        Transform in the "Default Portal Xform" Property.</p>
                    <img width=502 height=169 src="/2019.CRCS-WebSite/Documentation/assets/img/image007.png">
                    <h3>RoomWorld</h3>
                    <p>RoomWorld inderits from PortalWorld but gives you one extra bit of functionality: you can load
                        tango rooms with it. Simply give it the name of the scanned room ("Room Name"), and it will
                        attempt to load the scanned room as part of the world.
                        <br>
                        Note: for the RoomWorld to work, you also need a RoomLoader Component. You do NOT need to give
                        it a roomFolder property.</p>
                    <img width=513 height=301 src="/2019.CRCS-WebSite/Documentation/assets/img/image008.png">

                    <h1>How to Explore an ASL Scene</h1>
                    <h2>ASL Player</h2>
                    <p>ASL Player is a prefab that can be found in 'ASL/Utility' and will create
                        a basic player for moving in an ASL scene on the PC. It can be created by dragging the prefab
                        into the hierarchy.
                        Upon joining the ASL room the player will be created. The player is then controlled with
                        the WSAD or directional key buttons and the mouse. Gravity can be toggled by pressing G &
                        clipping through objects can be toggled by pressing C.
                        These are controlled by the <a
                            href="/2019.CRCS-WebSite/Documentation/api/ASL.PlayerSystem/PlayerController/">PlayerController</a>
                        class, along with other parameters like speed.</p>
                    <img width=400 src="/2019.CRCS-WebSite/Documentation/assets/img/ASLPlayer.PNG">
                    <p>The position and scale of the player can be controlled by the Initial Position and Initial Scale
                        fields.</p>
                    <p><b>Note:</b> The avatar material isn't synchronized between clients, this could be implemented in
                        the future.</p>
                    <p><b>Note:</b> In order for a player to use portals it must have a rigidbody & collider component.
                    </p>
                    </br>
                    <h2>VR Player</h2>
                    <p>See the <a href="/2019.CRCS-WebSite/Documentation/VR/tutorial/">VR Tutorial</a> for instructions
                        on creating and using a VR player.</p>
                    <h1>How to Use the Portal System</h1>
                    <h2>The Portal Manager Object</h2>
                    <p>Any scene that needs to use the Portal System MUST include one PortalManager Object. This Object
                        can be found in ASL/PortalSystem. Like other Manager type Objects, PortalManager has a
                        MasterClient property to set. This ensures that only the Master Client propagates portal related
                        events to the rest of the Clients. </p>
                    <img width=434 height=102 src="/2019.CRCS-WebSite/Documentation/assets/img/image009.png">
                    <p>The Player property can be set if your scene contains a GameObject for the user avatar prior to
                        runtime (this only applies if the user avatar won't be an Object shared among all Clients). If
                        you are loading in a user avatar at runtime, you should set this property at that time. It isn't
                        required if you are just using the main camera for the user. Otherwise, it should be set to
                        ensure portal displays use the correct perspective. The Portal Cursor is an optional property
                        that you can set using the provided PortalCursor prefab (more on this below). Setting it
                        provides a cursor interface for the user to create, register, and link portals. See the API
                        documentation for more on how to use the PortalManager class. </p>
                    <h2>Portals</h2>
                    <p>Since portals will presumably be shared and synchronized GameObjects, their prefab is contained
                        in ASL/Resources/Prefabs/Portals. The prefab we have provided contains a framed in, rectangular
                        portal. It has a Box Collider that covers the entire frame (it's not necessary for a portal
                        collider to perfectly wrap the plane used for the portal). A portal has just a few properties,
                        most of which are already set for you. </p>
                    <img width=433 height=426 src="/2019.CRCS-WebSite/Documentation/assets/img/image010.png">
                    <p>The Render Quad property is the portal's reference to the quad being used as the actual portal.
                        The View Type property tells the source portal what to render when using that portal as a
                        destination. Virtual means that the source portal will see only virtual space (things you've
                        constructed within Unity). Physical means that the source portal will try to use a web cam, or
                        other device, to peer into the real world. Currently, you cannot actually teleport to a Physical
                        portal, but in the future our intentions are to simulate teleporting to the real world through
                        the use of several cameras. To address this issue we have another View Type, Hybrid. This allows
                        you to see the same view as your webcam, but also teleport into a virtual scan of that room.
                        Check out the demo to see what the different View Types are like. The Copy Camera Prefab is just
                        a basic Camera that a portal uses to for rendering what the user should see through it, and
                        doesn't need to be changed. The Idle Mat property can be customized to whatever material you
                        want to see when first creating a portal, or on a portal that isn't linked. The other materials
                        shouldn't be changed, as they are used for rendering in different View Types. </p>
                    <h3>Using Portals</h3>
                    <p>Portals should always be created, registered, unregistered, linked, and unlinked through the
                        PortalManager to ensure that the event propagates to all Clients. Once a portal is created, it
                        must be registered before it can be linked to any other portal. Once a portal is linked, any
                        GameObject with a collider (trigger or not) can be teleported through it upon collision. Portals
                        can even be linked to themselves, so that if something goes into the portal, it comes right back
                        out. </p>
                    <h3>Customizing Portals</h3>
                    <p>Portals can be customized to whatever shape and size you may need. You can create another prefab
                        similar in structure (Portal-type script and Collider on parent GameObject with at least one
                        child for rendering the portal), and extend the Portal class with your own mesh generating
                        script. For example, let's say you want a circular portal, but Unity doesn't offer a 2D,
                        circular mesh. To achieve that you can use a script similar to this:</p>
                    <img width=505 height=499 src="/2019.CRCS-WebSite/Documentation/assets/img/image012.png">
                    <p>The mesh component of the portal is cleared and new vertices/triangles are generated in a circle.
                        You can then scale your prefab to create any elliptical shape you choose. Be sure to also set
                        the mesh uv so that you can still display the idle material on your portal. </p>
                    <h2>The Portal Cursor Object</h2>
                    <p>The Portal Cursor can optionally be used for a cursor interface to using portals. Simply make
                        sure that the PortalManager Object has it's Portal Cursor property set to a PortalCursor prefab.
                        Alternatively, make sure the PortalManager does not have any reference to a PortalCursor if you
                        do not want to use it. When using the PortalCursor prefab we have provided, it comes with a
                        large set of controls as follows:
                        <br>
                        P - enable/disable portal cursor
                        <br>
                        Space - Create virtual portal
                        <br>
                        C - Create webcam portal
                        <br>
                        R - Register portal
                        <br>
                        T - Set source portal
                        <br>
                        Y - Set destination portal
                        <br>
                        U - Link source to destination portal
                        <br>
                        X - Unlink portal
                        <br>
                        Left/Right Arrows - Rotate the cursor to set the front direction of a portal
                        <br>
                        As you can see, the cursor can be toggled on and off so that it is only displayed when being
                        used. Check out the demo to see it being used to create a few circular portals. </p>
                    <h3>Defining Your Own Controls</h3>
                    <p>Since your project may have its own set of controls, but you still need the functionality
                        provided by the Portal Cursor, the PortalCursor class can be extended. To define your own
                        controls for the Portal Cursor, just override one method in particular, PlayerPortalControls,
                        with your own set of controls. Be sure to use the PortalManager reference for any portal related
                        events, and you MUST call UpdateCursorTransform from within this method. This allows you to only
                        update it's position/orientation when the Portal Cursor is toggled on. </p>
                    <img width=518 height=313 src="/2019.CRCS-WebSite/Documentation/assets/img/image013.png">
                    <h2>The Portal Selector Object</h2>
                    <p>The Portal Selector Object is provide as a way to easily link portals. The prefab contains a
                        simple post with a button on the front. Feel free to customize the prefab to your own liking as
                        long as the parent GameObject has a PortalSelector script component. When clicking the button
                        with your mouse, assuming it's attached to a registered portal, it will link the portal the next
                        registered portal. Continue to click this button to cycle through all of the registered portals,
                        including the portal it's attached to. The PortalSelector class is quite simple, and just
                        requires a reference to the Portal you want it to control and the Camera being used for
                        initialization (for raycasting button clicks). Be sure to first Instantiate it use the
                        NetworkManager's InstantiateOwnedObject if it should be shared and synchronized between Clients.
                        It will update so that it is always positioned on the left side of its portal, facing the same
                        direction. Feel free to change the distance it's positioned from the portal inside of the
                        PortalSelector Update method. Currently it is always positioned 1.5 units to the left of the
                        portal. You can see these in action by checking out our demo. </p>
                    <h2>The Portal Instantiator</h2>
                    <p>An alternative way of making portals is to use the Portal Instantiator prefab found in
                        'ASL/Utility/'. This prefab allows you
                        to simply drag the prefab into the hierarchy, and upon joining a room a portal will be created.
                        The Portal Instantiator features
                        multiple fields which can be used to assign a name to the portal, include a selector, and set
                        another portal as the destination
                        before runtime.</p>
                    <img width=450 src="/2019.CRCS-WebSite/Documentation/assets/img/PortalInstantiator.PNG">
                    <p><b>Note:</b> The instantiator has some syncing issues with clients, see source comments for more
                        details</p>
                    <p>The Portal Instantiator features a portal renderable in the editor scene which reflects the
                        position of the portal
                        of portal at runtime. The transform of the prefab will be used for setting the transform of the
                        portal.</p>

                    <p>The name field is used in conjunction with the set destination field. When the set destination
                        field is enabled
                        the created portal will automatically set its destination to a portal with a name matching the
                        destination name field.</p>
                </section>

            </div>

            <!-- Footer -->
            <footer class="main-footer">
            </footer>

        </div>
        <div class="wrapper bottom-wrapper">
            <footer class="bottom-footer">
                Generated by <a href="https://wyam.io">Wyam</a>
            </footer>
        </div>
        <a href="javascript:" id="return-to-top"><i class="fa fa-chevron-up"></i></a>

        <script>
            // Close the sidebar if we select an anchor link
            $(".main-sidebar a[href^='#']:not('.expand')").click(function () {
                $(document.body).removeClass('sidebar-open');
            });

            $(document).load(function () {
                mermaid.initialize({
                    flowchart: {
                        htmlLabels: false,
                        useMaxWidth: false
                    }
                });
                mermaid.init(undefined, ".mermaid")
                $('svg').addClass('img-responsive');

                $('pre code').each(function (i, block) {
                    hljs.highlightBlock(block);
                });
            });
            hljs.initHighlightingOnLoad();

            // Back to top
            $(window).scroll(function () {
                if ($(this).scrollTop() >= 200) { // If page is scrolled more than 50px
                    $('#return-to-top').fadeIn(1000); // Fade in the arrow
                } else {
                    $('#return-to-top').fadeOut(1000); // Else fade out the arrow
                }
            });
            $('#return-to-top').click(function () { // When arrow is clicked
                $('body,html').animate({
                    scrollTop: 0 // Scroll to top of body
                }, 500);
            });
        </script>
    </body>

</html>